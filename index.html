<!doctype html>
<html lang="fr">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>Quest VR – Move + Grab + Highlight (smooth turn)</title>

  <!-- A-Frame 1.7.0 -->
  <script src="https://aframe.io/releases/1.7.0/aframe.min.js"></script>

  <!-- éviter le conflit de nom "grabbable" avec super-hands -->
  <script> if (AFRAME.components && AFRAME.components.grabbable) { delete AFRAME.components.grabbable; } </script>

  <script src="https://cdn.jsdelivr.net/gh/c-frame/aframe-extras@7.5.2/dist/aframe-extras.min.js"></script>

  <script src="https://cdn.jsdelivr.net/npm/@c-frame/aframe-physics-system@4.1.0/dist/aframe-physics-system.min.js"></script>

  <script src="https://unpkg.com/super-hands@3.0.5/dist/super-hands.min.js"></script>

  <style>
    body{margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,sans-serif}
    .overlay{position:fixed;left:12px;top:12px;z-index:9;background:#0009;color:#fff;padding:10px 12px;border-radius:10px;font-size:14px;line-height:1.35}
    .overlay kbd{background:#222;padding:2px 6px;border-radius:6px}
  </style>

  <script>
    AFRAME.registerComponent('left-stick-move', {
      schema:{rig:{type:'selector'}, speed:{default:2.2}, dead:{default:0.18}},
      init(){
        this.vx=0; this.vy=0;
        this.onThumb = e=>{
          const x=e.detail.x||0, y=e.detail.y||0;
          this.vx = (Math.abs(x)>this.data.dead)? x : 0;
          this.vy = (Math.abs(y)>this.data.dead)? y : 0;
        };
        this.el.addEventListener('thumbstickmoved', this.onThumb);
        this.el.addEventListener('axismove', e=>{
          if(!e.detail||!Array.isArray(e.detail.axis)) return;
          const x=e.detail.axis[0]||0, y=e.detail.axis[1]||0;
          this.vx = (Math.abs(x)>this.data.dead)? x : 0;
          this.vy = (Math.abs(y)>this.data.dead)? y : 0;
        });
      },
      tick(t,dt){
        const rigEl=this.data.rig; if(!rigEl) return;
        if(!this.vx && !this.vy) return;
        const rig=rigEl.object3D;
        const yaw = THREE.MathUtils.degToRad(rigEl.getAttribute('rotation').y);
        const cos=Math.cos(yaw), sin=Math.sin(yaw);
        const forward=this.vy;   // pousser vers l'avant :"forward"
        const strafe = this.vx;
        const step=this.data.speed*(dt/1000);
        const dx = (strafe*cos + forward*sin)*step;
        const dz = (forward*cos - strafe*sin)*step;
        rig.position.x += dx; rig.position.z += dz;
      },
      remove(){ this.el.removeEventListener('thumbstickmoved', this.onThumb); }
    });

    AFRAME.registerComponent('right-stick-smoothturn', {
      schema:{rig:{type:'selector'}, speedDeg:{default:140}, dead:{default:0.18}},
      init(){
        this.x=0;
        this.onThumb = e=>{
          const x=e.detail.x||0;
          this.x = (Math.abs(x)>this.data.dead)? x : 0;
        };
        this.el.addEventListener('thumbstickmoved', this.onThumb);
        this.el.addEventListener('axismove', e=>{
          if(!e.detail||!Array.isArray(e.detail.axis)) return;
          const x=e.detail.axis[0]||0;
          this.x = (Math.abs(x)>this.data.dead)? x : 0;
        });
      },
      tick(t,dt){
        const rig=this.data.rig; if(!rig||!this.x) return;
        const rot=rig.getAttribute('rotation');
        rot.y -= this.x * this.data.speedDeg * (dt/1000); // signe façon FPS
        rig.setAttribute('rotation', rot);
      },
      remove(){ this.el.removeEventListener('thumbstickmoved', this.onThumb); }
    });

    // Surbrillance (scale + émissif) via super-hands
AFRAME.registerComponent('hover-highlight', {
  schema:{scale:{default:1.06}, emissive:{default:'#ffffff'}, intensity:{default:0.45}},
  init(){
    const el=this.el;
    this.s0=el.object3D.scale.clone();

    const getMat=()=>{const m=el.getObject3D('mesh'); return m? (Array.isArray(m.material)?m.material[0]:m.material):null;};
    this.mat=getMat();
    this.e0=(this.mat&&this.mat.emissive)? this.mat.emissive.clone():null;
    this.i0=(this.mat&&'emissiveIntensity'in this.mat)? this.mat.emissiveIntensity:0;

    // ✅ Survol par super-hands (prox & rayon via colliderEvent) :
    el.addEventListener('hover-start', ()=>this.set(true));
    el.addEventListener('hover-end',   ()=>this.set(false));

    // ✅ Survol direct via raycaster (fallback direct) :
    el.addEventListener('raycaster-intersected', ()=>this.set(true));
    el.addEventListener('raycaster-intersected-cleared', ()=>this.set(false));

    // ❌ NE PAS écouter grab-start / grab-end (source du "ghost highlight")
  },
  set(on){
    const el=this.el;
    el.object3D.scale.setScalar(on? this.data.scale : this.s0.x);
    if(this.mat){
      if(on){
        (this.mat.emissive||(this.mat.emissive=new THREE.Color(this.data.emissive))).set(this.data.emissive);
        this.mat.emissiveIntensity=this.data.intensity;
      }else{
        if(this.e0) this.mat.emissive.copy(this.e0);
        this.mat.emissiveIntensity=this.i0;
      }
      this.mat.needsUpdate=true;
    }
  }
});


AFRAME.registerComponent('vr-grab-attach', {
  schema:{ holdOffset:{type:'vec3', default:{x:0,y:0,z:-0.15}} }, // léger offset devant la main
  init(){
    this._held = null;
    this._lastPos = new THREE.Vector3();
    this._tmp = new THREE.Vector3();

    this._onGrabStart = (e)=>{
      const hand = e.detail && e.detail.hand;
      if (!hand || this._held) return;

      // mémos
      const hadBody = this.el.hasAttribute('dynamic-body');
      if (hadBody) this.el.removeAttribute('dynamic-body');

      // parentage à la main en conservant une pose propre
      hand.object3D.updateMatrixWorld();
      this.el.sceneEl.object3D.updateMatrixWorld();

      // place l’objet comme enfant de la main
      hand.appendChild(this.el);

      // petit offset devant la main (évite de clipper la main)
      const o = this.data.holdOffset;
      this.el.object3D.position.set(o.x, o.y, o.z);
      this.el.object3D.rotation.set(0,0,0); // optionnel : aligne l’objet avec la main

      // init suivi vitesse
      const wp = hand.object3D.localToWorld(new THREE.Vector3(o.x,o.y,o.z));
      this._lastPos.copy(wp);

      this._held = { hand, hadBody };
    };

    this._onGrabEnd = ()=>{
      if (!this._held) return;
      const {hand, hadBody} = this._held;

      // calcul d’une vitesse de lâcher (diff de positions monde)
      const nowWorldPos = hand.object3D.localToWorld(this.el.object3D.position.clone());
      const vel = nowWorldPos.clone().sub(this._lastPos).multiplyScalar(60); // ≈ m/s

      // reparenter à la scène (garder la pose monde)
      const worldPos = nowWorldPos.clone();
      const worldQuat = this.el.object3D.getWorldQuaternion(new THREE.Quaternion());
      this.el.sceneEl.appendChild(this.el);
      this.el.object3D.position.copy(worldPos);
      this.el.object3D.setRotationFromQuaternion(worldQuat);

      // réactiver physique et pousser la vitesse
      if (hadBody){
        this.el.setAttribute('dynamic-body','mass:1');
        this.el.addEventListener('body-loaded', function onBody(){
          this.removeEventListener('body-loaded', onBody);
          if (this.body) this.body.velocity.set(vel.x, vel.y, vel.z);
        });
      }

      this._held = null;
    };

    this.el.addEventListener('grab-start', this._onGrabStart);
    this.el.addEventListener('grab-end',   this._onGrabEnd);
  },
  tick(){
    if (!this._held) return;
    // met à jour la position monde suivie (pour la vitesse)
    const o = this.data.holdOffset;
    const wp = this._held.hand.object3D.localToWorld(new THREE.Vector3(o.x,o.y,o.z));
    this._lastPos.copy(wp);
  },
  remove(){
    this.el.removeEventListener('grab-start', this._onGrabStart);
    this.el.removeEventListener('grab-end',   this._onGrabEnd);
  }
});

// Spawner d'objets sur une table fixe : sphère, cube, pistolet
AFRAME.registerComponent('table-spawn', {
  schema: {
    // id de la table (plateau) à utiliser
    tableId: {default: 'tableTop'}
  },
  init() {
    this.spawnAll = this.spawnAll.bind(this);
    // Spawn au démarrage (petit délai pour laisser la scène s'initialiser)
    setTimeout(this.spawnAll, 400);
    // Bouton A de la manette droite = respawn
    this.el.addEventListener('abuttondown', this.spawnAll);
    // Touche N du clavier = respawn (pratique sur desktop)
    window.addEventListener('keydown', e => {
      if ((e.key||'').toLowerCase() === 'n') this.spawnAll();
    });
  },

  // utilitaire: crée ou met à jour une entité avec attributs
  _make(tag, attrs) {
    const el = document.createElement(tag);
    for (const [k,v] of Object.entries(attrs)) el.setAttribute(k, v);
    return el;
  },

  // supprime les anciens objets spawnés
  _clearOld() {
    document.querySelectorAll('.spawned-on-table').forEach(n => n.remove());
  },

  spawnAll() {
    const scene = this.el.sceneEl;
    // 1) assurer la présence d'une table
    let table = document.getElementById(this.data.tableId);
    if (!table) {
      table = this._make('a-box', {
        id: this.data.tableId,
        position: '0 1.25 -3',
        width: 1.6, height: 0.05, depth: 0.9,
        color: '#8B5A2B',
        'static-body': '',
        shadow: 'cast:true; receive:true'
      });
      scene.appendChild(table);
      // 4 pieds simples (optionnels)
      const feet = [
        {x:-0.7, z:-3.35}, {x:0.7, z:-3.35}, {x:-0.7, z:-2.65}, {x:0.7, z:-2.65}
      ];
      feet.forEach(p=>{
        scene.appendChild(this._make('a-box',{
          position: `${p.x} 0.5 ${p.z}`,
          width:0.08, height:1.5, depth:0.08,
          color:'#6E4A20', 'static-body':'', shadow:'cast:true;receive:true'
        }));
      });
    }

    // 2) coordonnées du dessus de table
    const tPos = table.getAttribute('position');
    const tHeight = parseFloat(table.getAttribute('height')) || 0.05;
    const topY = tPos.y + tHeight/2;

    // 3) nettoyer les anciens
    this._clearOld();

    // Paramètres communs d’interaction
    const common = {
      class: 'grab-target hoverable grabbable spawned-on-table',
      'hover-highlight': '',
      'dynamic-body': 'mass:1',
      'vr-grab-attach': '' // ← notre composant d’attache main (que tu as ajouté)
    };

    // --- CUBE ---
    const cube = this._make('a-box', {
      ...common,
      color: '#4CC3D9',
      width: 0.5, height: 0.5, depth: 0.5,
      position: `${tPos.x - 0.5} ${topY + 0.25} ${tPos.z - 0.1}`,
      shadow: 'cast:true; receive:true',
      material: 'roughness:0.5; metalness:0.05'
    });
    scene.appendChild(cube);

    // --- SPHÈRE ---
    const sphere = this._make('a-sphere', {
      ...common,
      color: '#EF2D5E',
      radius: 0.35,
      position: `${tPos.x + 0.3} ${topY + 0.35} ${tPos.z - 0.2}`,
      shadow: 'cast:true; receive:true',
      material: 'roughness:0.5; metalness:0.05'
    });
    scene.appendChild(sphere);

    // --- “PISTOLET” (bloc simple) ---
    const gun = this._make('a-box', {
      ...common,
      color: '#222222',
      width: 0.12, height: 0.07, depth: 0.22,
      position: `${tPos.x + 0.7} ${topY + 0.035} ${tPos.z + 0.1}`,
      shadow: 'cast:true; receive:true',
      material: 'roughness:0.4; metalness:0.2'
    });
    scene.appendChild(gun);
  }
});
  </script>
</head>
<body>
  <div class="overlay">
    <strong>Commandes Quest</strong><br/>
    🧭 Stick gauche : se déplacer (avant/arrière corrigé) • 🔁 Stick droit : rotation <b>lisse</b><br/>
    🎯 Lasers par défaut depuis chaque manette • 🤏 Gâchettes : grab/drop<br/>
    ➕ Spawn objet : bouton <b>A</b> (droite) ou <kbd>N</kbd> (clavier)
  </div>

  <a-scene
    background="color:#20252b"
    renderer="colorManagement:true;physicallyCorrectLights:true;antialias:true;sortTransparentObjects:true"
    shadow="type:pcfsoft"
    physics="gravity:-9.8;debug:false"
    vr-mode-ui="enabled:true"
  >
    <!-- lumières -->
    <a-entity light="type:ambient; intensity:0.35; color:#ffffff"></a-entity>
    <a-entity light="type:directional; intensity:1; castShadow:true" position="2 6 3" rotation="-45 30 0"></a-entity>

    <!-- sol -->
    <a-plane rotation="-90 0 0" width="30" height="30"
             color="#3c424a" material="roughness:1; metalness:0"
             shadow="receive:true" static-body></a-plane>

    <!-- rig + caméra -->
    <a-entity id="rig" position="0 1.6 3">
      <a-entity id="cam" camera look-controls wasd-controls="enabled:false"></a-entity>


    // Table
    <a-box id="tableTop" position="0 1.25 -3" width="1.6" height="0.05" depth="0.9"
       color="#8B5A2B" static-body shadow="cast:true;receive:true"></a-box>


<!-- GAUCHE -->
<a-entity id="leftCtl"
  oculus-touch-controls="hand: left"
  left-stick-move="rig:#rig; speed:2.2; dead:0.18"
  laser-controls="hand: left"
  raycaster="objects:.grab-target; showLine:true; far:8; interval:0"
  sphere-collider="objects:.grab-target"
  super-hands="colliderEvent: raycaster-intersection;
               colliderEndEvent: raycaster-intersection-cleared;
               colliderEventProperty: els;
               grabStartButtons: triggerdown, gripdown;
               grabEndButtons: triggerup, gripup">
</a-entity>

<!-- DROITE -->
<a-entity id="rightCtl"
          oculus-touch-controls="hand: right"
          right-stick-smoothturn="rig:#rig; speedDeg:140; dead:0.18"
          laser-controls="hand: right"
          raycaster="objects:.grab-target; showLine:true; far:8; interval:0"
          sphere-collider="objects:.grab-target"
          super-hands="colliderEvent: raycaster-intersection;
                       colliderEndEvent: raycaster-intersection-cleared;
                       colliderEventProperty: els;
                       grabStartButtons: triggerdown, gripdown;
                       grabEndButtons: triggerup, gripup"
          table-spawn>
</a-entity>



    </a-entity>

    <a-sky color="#1b2026"></a-sky>
  </a-scene>
</body>
</html>
