<!doctype html>
<html lang="fr">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>Quest VR ‚Äì Move + Grab + Highlight (smooth turn)</title>

  <!-- A-Frame 1.7.0 -->
  <script src="https://aframe.io/releases/1.7.0/aframe.min.js"></script>

  <!-- √©viter le conflit de nom "grabbable" avec super-hands -->
  <script> if (AFRAME.components && AFRAME.components.grabbable) { delete AFRAME.components.grabbable; } </script>

  <script src="https://cdn.jsdelivr.net/gh/c-frame/aframe-extras@7.5.2/dist/aframe-extras.min.js"></script>

  <script src="https://cdn.jsdelivr.net/npm/@c-frame/aframe-physics-system@4.1.0/dist/aframe-physics-system.min.js"></script>

  <script src="https://unpkg.com/super-hands@3.0.5/dist/super-hands.min.js"></script>

  <style>
    body{margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,sans-serif}
    .overlay{position:fixed;left:12px;top:12px;z-index:9;background:#0009;color:#fff;padding:10px 12px;border-radius:10px;font-size:14px;line-height:1.35}
    .overlay kbd{background:#222;padding:2px 6px;border-radius:6px}
  </style>

  <script>
    AFRAME.registerComponent('left-stick-move', {
      schema:{rig:{type:'selector'}, speed:{default:2.2}, dead:{default:0.18}},
      init(){
        this.vx=0; this.vy=0;
        this.onThumb = e=>{
          const x=e.detail.x||0, y=e.detail.y||0;
          this.vx = (Math.abs(x)>this.data.dead)? x : 0;
          this.vy = (Math.abs(y)>this.data.dead)? y : 0;
        };
        this.el.addEventListener('thumbstickmoved', this.onThumb);
        this.el.addEventListener('axismove', e=>{
          if(!e.detail||!Array.isArray(e.detail.axis)) return;
          const x=e.detail.axis[0]||0, y=e.detail.axis[1]||0;
          this.vx = (Math.abs(x)>this.data.dead)? x : 0;
          this.vy = (Math.abs(y)>this.data.dead)? y : 0;
        });
      },
      tick(t,dt){
        const rigEl=this.data.rig; if(!rigEl) return;
        if(!this.vx && !this.vy) return;
        const rig=rigEl.object3D;
        const yaw = THREE.MathUtils.degToRad(rigEl.getAttribute('rotation').y);
        const cos=Math.cos(yaw), sin=Math.sin(yaw);
        const forward=this.vy;   // pousser vers l'avant :"forward"
        const strafe = this.vx;
        const step=this.data.speed*(dt/1000);
        const dx = (strafe*cos + forward*sin)*step;
        const dz = (forward*cos - strafe*sin)*step;
        rig.position.x += dx; rig.position.z += dz;
      },
      remove(){ this.el.removeEventListener('thumbstickmoved', this.onThumb); }
    });

    AFRAME.registerComponent('right-stick-smoothturn', {
      schema:{rig:{type:'selector'}, speedDeg:{default:140}, dead:{default:0.18}},
      init(){
        this.x=0;
        this.onThumb = e=>{
          const x=e.detail.x||0;
          this.x = (Math.abs(x)>this.data.dead)? x : 0;
        };
        this.el.addEventListener('thumbstickmoved', this.onThumb);
        this.el.addEventListener('axismove', e=>{
          if(!e.detail||!Array.isArray(e.detail.axis)) return;
          const x=e.detail.axis[0]||0;
          this.x = (Math.abs(x)>this.data.dead)? x : 0;
        });
      },
      tick(t,dt){
        const rig=this.data.rig; if(!rig||!this.x) return;
        const rot=rig.getAttribute('rotation');
        rot.y -= this.x * this.data.speedDeg * (dt/1000); // signe fa√ßon FPS
        rig.setAttribute('rotation', rot);
      },
      remove(){ this.el.removeEventListener('thumbstickmoved', this.onThumb); }
    });

    // Surbrillance (scale + √©missif) via super-hands
AFRAME.registerComponent('hover-highlight', {
  schema:{scale:{default:1.06}, emissive:{default:'#ffffff'}, intensity:{default:0.45}},
  init(){
    const el=this.el;
    this.s0=el.object3D.scale.clone();

    const getMat=()=>{const m=el.getObject3D('mesh'); return m? (Array.isArray(m.material)?m.material[0]:m.material):null;};
    this.mat=getMat();
    this.e0=(this.mat&&this.mat.emissive)? this.mat.emissive.clone():null;
    this.i0=(this.mat&&'emissiveIntensity'in this.mat)? this.mat.emissiveIntensity:0;

    // ‚úÖ Survol par super-hands (prox & rayon via colliderEvent) :
    el.addEventListener('hover-start', ()=>this.set(true));
    el.addEventListener('hover-end',   ()=>this.set(false));

    // ‚úÖ Survol direct via raycaster (fallback direct) :
    el.addEventListener('raycaster-intersected', ()=>this.set(true));
    el.addEventListener('raycaster-intersected-cleared', ()=>this.set(false));

    // ‚ùå NE PAS √©couter grab-start / grab-end (source du "ghost highlight")
  },
  set(on){
    const el=this.el;
    el.object3D.scale.setScalar(on? this.data.scale : this.s0.x);
    if(this.mat){
      if(on){
        (this.mat.emissive||(this.mat.emissive=new THREE.Color(this.data.emissive))).set(this.data.emissive);
        this.mat.emissiveIntensity=this.data.intensity;
      }else{
        if(this.e0) this.mat.emissive.copy(this.e0);
        this.mat.emissiveIntensity=this.i0;
      }
      this.mat.needsUpdate=true;
    }
  }
});


AFRAME.registerComponent('vr-grab-attach', {
  schema:{ holdOffset:{type:'vec3', default:{x:0,y:0,z:-0.15}} }, // l√©ger offset devant la main
  init(){
    this._held = null;
    this._lastPos = new THREE.Vector3();
    this._tmp = new THREE.Vector3();

    this._onGrabStart = (e)=>{
      const hand = e.detail && e.detail.hand;
      if (!hand || this._held) return;

      // m√©mos
      const hadBody = this.el.hasAttribute('dynamic-body');
      if (hadBody) this.el.removeAttribute('dynamic-body');

      // parentage √† la main en conservant une pose propre
      hand.object3D.updateMatrixWorld();
      this.el.sceneEl.object3D.updateMatrixWorld();

      // place l‚Äôobjet comme enfant de la main
      hand.appendChild(this.el);

      // petit offset devant la main (√©vite de clipper la main)
      const o = this.data.holdOffset;
      this.el.object3D.position.set(o.x, o.y, o.z);
      this.el.object3D.rotation.set(0,0,0); // optionnel : aligne l‚Äôobjet avec la main

      // init suivi vitesse
      const wp = hand.object3D.localToWorld(new THREE.Vector3(o.x,o.y,o.z));
      this._lastPos.copy(wp);

      this._held = { hand, hadBody };
    };

    this._onGrabEnd = ()=>{
      if (!this._held) return;
      const {hand, hadBody} = this._held;

      // calcul d‚Äôune vitesse de l√¢cher (diff de positions monde)
      const nowWorldPos = hand.object3D.localToWorld(this.el.object3D.position.clone());
      const vel = nowWorldPos.clone().sub(this._lastPos).multiplyScalar(60); // ‚âà m/s

      // reparenter √† la sc√®ne (garder la pose monde)
      const worldPos = nowWorldPos.clone();
      const worldQuat = this.el.object3D.getWorldQuaternion(new THREE.Quaternion());
      this.el.sceneEl.appendChild(this.el);
      this.el.object3D.position.copy(worldPos);
      this.el.object3D.setRotationFromQuaternion(worldQuat);

      // r√©activer physique et pousser la vitesse
      if (hadBody){
        this.el.setAttribute('dynamic-body','mass:1');
        this.el.addEventListener('body-loaded', function onBody(){
          this.removeEventListener('body-loaded', onBody);
          if (this.body) this.body.velocity.set(vel.x, vel.y, vel.z);
        });
      }

      this._held = null;
    };

    this.el.addEventListener('grab-start', this._onGrabStart);
    this.el.addEventListener('grab-end',   this._onGrabEnd);
  },
  tick(){
    if (!this._held) return;
    // met √† jour la position monde suivie (pour la vitesse)
    const o = this.data.holdOffset;
    const wp = this._held.hand.object3D.localToWorld(new THREE.Vector3(o.x,o.y,o.z));
    this._lastPos.copy(wp);
  },
  remove(){
    this.el.removeEventListener('grab-start', this._onGrabStart);
    this.el.removeEventListener('grab-end',   this._onGrabEnd);
  }
});



    // Spawner : bouton A (droite) ou touche N ‚Äî (laisse comme pr√©c√©demment)
    AFRAME.registerComponent('spawner', {
      schema:{camera:{type:'selector'}},
      init(){
        this.spawn=this.spawn.bind(this);
        this.el.addEventListener('abuttondown', this.spawn);
        window.addEventListener('keydown', e=>{ if(e.key.toLowerCase()==='n') this.spawn(); });
        setTimeout(()=>{ this.spawn(); this.spawn(); this.spawn(); }, 400);
      },
      spawn(){
        const camEl=this.data.camera; if(!camEl) return;
        const cam=camEl.object3D, dir=new THREE.Vector3(); cam.getWorldDirection(dir);
        dir.y=0; dir.normalize();
        // garde le spawn devant toi (ajust√© pr√©c√©demment)
        const origin=camEl.object3D.getWorldPosition(new THREE.Vector3());
        const pos=origin.clone().add(dir.multiplyScalar(-1.4)); // -1.4 pour "devant" selon la direction retourn√©e
        pos.y=1.3;

        const isBox=Math.random()<0.5;
        const el=document.createElement(isBox?'a-box':'a-sphere');
        el.className='grab-target hoverable grabbable';
        if(isBox){ el.setAttribute('width',0.45); el.setAttribute('height',0.45); el.setAttribute('depth',0.45);}
        else{ el.setAttribute('radius',0.28); }
        el.setAttribute('color','#'+(Math.random()*0xFFFFFF|0).toString(16).padStart(6,'0'));
        el.setAttribute('position',`${pos.x} ${pos.y} ${pos.z}`);
        el.setAttribute('material','roughness:0.5; metalness:0.05');
        el.setAttribute('hover-highlight','');
        el.setAttribute('hoverable','');
        el.setAttribute('grabbable','');
        el.setAttribute('draggable','');
        el.setAttribute('dynamic-body','mass:1');
        el.setAttribute('vr-grab-attach','');
        document.querySelector('a-scene').appendChild(el);
      }
    });
  </script>
</head>
<body>
  <div class="overlay">
    <strong>Commandes Quest</strong><br/>
    üß≠ Stick gauche : se d√©placer (avant/arri√®re corrig√©) ‚Ä¢ üîÅ Stick droit : rotation <b>lisse</b><br/>
    üéØ Lasers par d√©faut depuis chaque manette ‚Ä¢ ü§è G√¢chettes : grab/drop<br/>
    ‚ûï Spawn objet : bouton <b>A</b> (droite) ou <kbd>N</kbd> (clavier)
  </div>

  <a-scene
    background="color:#20252b"
    renderer="colorManagement:true;physicallyCorrectLights:true;antialias:true;sortTransparentObjects:true"
    shadow="type:pcfsoft"
    physics="gravity:-9.8;debug:false"
    vr-mode-ui="enabled:true"
  >
    <!-- lumi√®res -->
    <a-entity light="type:ambient; intensity:0.35; color:#ffffff"></a-entity>
    <a-entity light="type:directional; intensity:1; castShadow:true" position="2 6 3" rotation="-45 30 0"></a-entity>

    <!-- sol -->
    <a-plane rotation="-90 0 0" width="30" height="30"
             color="#3c424a" material="roughness:1; metalness:0"
             shadow="receive:true" static-body></a-plane>

    <!-- rig + cam√©ra -->
    <a-entity id="rig" position="0 1.6 3">
      <a-entity id="cam" camera look-controls wasd-controls="enabled:false"></a-entity>

      <!-- MAIN GAUCHE : locomotion -->
<!-- GAUCHE -->
<a-entity id="leftCtl"
  oculus-touch-controls="hand: left"
  left-stick-move="rig:#rig; speed:2.2; dead:0.18"
  laser-controls="hand: left"
  raycaster="objects:.grab-target; showLine:true; far:8; interval:0"
  sphere-collider="objects:.grab-target"
  super-hands="colliderEvent: raycaster-intersection;
               colliderEndEvent: raycaster-intersection-cleared;
               colliderEventProperty: els;
               grabStartButtons: triggerdown, gripdown;
               grabEndButtons: triggerup, gripup">
</a-entity>

<!-- DROITE -->
<a-entity id="rightCtl"
  oculus-touch-controls="hand: right"
  right-stick-smoothturn="rig:#rig; speedDeg:140; dead:0.18"
  laser-controls="hand: right"
  raycaster="objects:.grab-target; showLine:true; far:8; interval:0"
  sphere-collider="objects:.grab-target"
  super-hands="colliderEvent: raycaster-intersection;
               colliderEndEvent: raycaster-intersection-cleared;
               colliderEventProperty: els;
               grabStartButtons: triggerdown, gripdown;
               grabEndButtons: triggerup, gripup"
  spawner="camera:#cam">
</a-entity>


    </a-entity>

    <a-sky color="#1b2026"></a-sky>
  </a-scene>
</body>
</html>
