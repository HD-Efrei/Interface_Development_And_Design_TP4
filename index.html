<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>VR Mini Playground – Grab & Throw Mechanics</title>

    <!-- A-Frame 0.9.2 + Physics + Extras -->
    <script src="https://aframe.io/releases/0.9.2/aframe.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/cannon@0.6.2/build/cannon.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/aframe-physics-system@3.3.0/dist/aframe-physics-system.min.js"></script>
    <script src="https://unpkg.com/aframe-extras@4.1.2/dist/aframe-extras.min.js"></script>
    <script src="https://unpkg.com/super-hands@3.0.3/dist/super-hands.min.js"></script>
    <script src="https://unpkg.com/aframe-particle-system-component@1.0.9/dist/aframe-particle-system-component.min.js"></script>

    <style>
      html, body {height: 100%; margin: 0;}
      .hud {position: fixed; left: 12px; top: 12px; padding: 8px 12px;
            background: #0008; color: #fff; border-radius: 8px;
            font: 13px system-ui; z-index: 9; pointer-events: none;}
      #enterVrBtn {position: fixed; right: 12px; bottom: 12px; z-index: 10;}
    </style>
  </head>
  <body>
    <div class="hud">
      Déplacement: Z/Q/S/D ou flèches · Rotation: <b>A</b>/<b>E</b> ·
      Attraper/Lâcher (desktop) : <b>F</b> · Viser avec le rayon
    </div>
    <button id="enterVrBtn">Entrer en VR</button>

    <script>
      /* ---------------------------------------
       *  Auto-focus the canvas on load & VR toggles
       */
      AFRAME.registerComponent('autofocus-canvas', {
        init() {
          const scene = this.el.sceneEl;
          const focusCanvas = () => {
            const c = scene.canvas;
            if (!c) return;
            c.setAttribute('tabindex', '0');
            c.focus();
            window.focus();
          };
          if (scene.hasLoaded) focusCanvas(); else scene.addEventListener('loaded', focusCanvas);
          scene.addEventListener('enter-vr', focusCanvas);
          scene.addEventListener('exit-vr', focusCanvas);
          window.addEventListener('click', focusCanvas, {capture: true});
          window.addEventListener('touchstart', focusCanvas, {capture: true});
        }
      });

      /* ---------------------------------------
       * Refresh the physics shape if geometry or scale change
       */
      AFRAME.registerComponent('auto-refresh-physics', {
        schema: { watch: {default: 'geometry,scale'} },
        init() {
          const el = this.el;
          const queue = () => {
            if (this._job) return;
            this._job = setTimeout(() => {
              this._job = null;
              const attr = el.hasAttribute('dynamic-body') ? 'dynamic-body'
                         : el.hasAttribute('static-body')   ? 'static-body'   : null;
              if (!attr) return;
              const val = el.getAttribute(attr);
              el.removeAttribute(attr);
              requestAnimationFrame(() => el.setAttribute(attr, val || ''));
            }, 0);
          };
          el.addEventListener('componentchanged', (e) => {
            if (['geometry','scale'].includes(e.detail.name)) queue();
          });
        },
        remove() {
          if (this._job) {
            clearTimeout(this._job);
            this._job = null;
          }
        }
      });

      /* ---------------------------------------
       * Dual joystick controls (AZERTY & QWERTY)
       */
      AFRAME.registerComponent('dual-joystick-controls', {
        schema: { moveSpeed: {default: 0.1}, turnSpeed: {default: 2.0} },
        init() {
          this.leftX = 0; this.leftY = 0; this.rightX = 0;
          this.keys = {fw:false, bk:false, lf:false, rt:false, turnL:false, turnR:false};
          const mapKey = {
            'z':'fw','q':'lf','s':'bk','d':'rt',
            'w':'fw','a':'lf','s':'bk','d':'rt',
            'arrowup':'fw','arrowleft':'lf','arrowdown':'bk','arrowright':'rt',
            'a':'turnL','e':'turnR'
          };
          this.cam = this.el.querySelector('#cam') || this.el.querySelector('[camera]');
          const left  = this.el.querySelector('#left');
          const right = this.el.querySelector('#right');
          if (left) {
            left.addEventListener('axismove', (e) => {
              this.leftX = e.detail.axis[0] || 0;
              this.leftY = e.detail.axis[1] || 0;
            });
          }
          if (right) {
            right.addEventListener('axismove', (e) => {
              this.rightX = (e.detail.axis[2] !== undefined ? e.detail.axis[2] : e.detail.axis[0]) || 0;
            });
          }
          const ignore = () => {
            const el = document.activeElement; const t = el && el.tagName;
            return t === 'INPUT' || t === 'TEXTAREA' || (el && el.isContentEditable);
          };
          this._kd = (e) => {
            if (ignore()) return;
            const key = (e.key || '').toLowerCase();
            const act = mapKey[key];
            if (!act) return;
            e.preventDefault(); e.stopPropagation();
            this.keys[act] = true;
          };
          this._ku = (e) => {
            if (ignore()) return;
            const key = (e.key || '').toLowerCase();
            const act = mapKey[key];
            if (!act) return;
            e.preventDefault(); e.stopPropagation();
            this.keys[act] = false;
          };
          window.addEventListener('keydown', this._kd, {capture: true});
          window.addEventListener('keyup', this._ku, {capture: true});
          this._fwd = new THREE.Vector3();
          this._right = new THREE.Vector3();
          this._up = new THREE.Vector3(0, 1, 0);
        },
        remove() {
          window.removeEventListener('keydown', this._kd, {capture: true});
          window.removeEventListener('keyup', this._ku, {capture: true});
        },
        tick(time, dt) {
          dt = dt || 16;
          const dead = (v) => Math.abs(v) > 0.18 ? v : 0;
          const jx = dead(this.leftX);
          const jy = dead(this.leftY);
          let ix = 0, iy = 0;
          if (this.keys.fw) iy -= 1;
          if (this.keys.bk) iy += 1;
          if (this.keys.lf) ix -= 1;
          if (this.keys.rt) ix += 1;
          const moveX = jx + ix;
          const moveY = jy + iy;
          let rx = dead(this.rightX);
          if (this.keys.turnL) rx -= 0.8;
          if (this.keys.turnR) rx += 0.8;
          if (rx) {
            this.el.object3D.rotation.y -= rx * (this.data.turnSpeed * Math.PI / 180);
          }
          if ((moveX || moveY) && this.cam) {
            this.cam.object3D.getWorldDirection(this._fwd);
            this._fwd.y = 0;
            if (this._fwd.lengthSq() < 1e-6) this._fwd.set(0, 0, -1);
            this._fwd.normalize();
            this._right.copy(this._up).cross(this._fwd).normalize();
            const speed = this.data.moveSpeed * (dt / 16);
            const dx = this._fwd.x * (moveY) * speed + this._right.x * (moveX) * speed;
            const dz = this._fwd.z * (moveY) * speed + this._right.z * (moveX) * speed;
            const o = this.el.object3D;
            o.position.x += dx;
            o.position.z += dz;
          }
        }
      });

      /* ---------------------------------------
       * Hover-highlight: emissive + color on hover/grab
       */
      AFRAME.registerComponent('hover-highlight', {
        schema: { color:{default:'#ffff66'}, emissive:{default:'#444444'} },
        init() {
          this._onEnter = () => this.setHighlight(true);
          this._onLeave = () => this.setHighlight(false);
          this.el.addEventListener('mouseenter', this._onEnter);
          this.el.addEventListener('mouseleave', this._onLeave);
          this.el.addEventListener('raycaster-intersected', this._onEnter);
          this.el.addEventListener('raycaster-intersected-cleared', this._onLeave);
          this.el.addEventListener('hover-start', this._onEnter);
          this.el.addEventListener('hover-end', this._onLeave);
          this.el.addEventListener('grab-start', this._onEnter);
          this.el.addEventListener('grab-end', this._onLeave);
        },
        remove() {
          this.el.removeEventListener('mouseenter', this._onEnter);
          this.el.removeEventListener('mouseleave', this._onLeave);
          this.el.removeEventListener('raycaster-intersected', this._onEnter);
          this.el.removeEventListener('raycaster-intersected-cleared', this._onLeave);
          this.el.removeEventListener('hover-start', this._onEnter);
          this.el.removeEventListener('hover-end', this._onLeave);
          this.el.removeEventListener('grab-start', this._onEnter);
          this.el.removeEventListener('grab-end', this._onLeave);
        },
        setHighlight(on) {
          if (!this._orig) {
            const mat = this.el.getAttribute('material') || {};
            this._orig = {
              color: mat.color || this.el.getAttribute('color') || '#fff',
              emissive: mat.emissive || '#000'
            };
          }
          if (on) this.el.setAttribute('material', `color:${this.data.color}; emissive:${this.data.emissive}`);
          else this.el.setAttribute('material', `color:${this._orig.color}; emissive:${this._orig.emissive}`);
        }
      });

      /* ---------------------------------------
       * Toggle between 'mouse' and 'entity' raycasting in VR vs desktop
       */
      AFRAME.registerComponent('toggle-cursor-rayorigin', {
        init() {
          const scene = this.el.sceneEl;
          const reticle = this.el.querySelector('#reticle');
          const setMode = (mode) => {
            this.el.setAttribute('cursor', 'rayOrigin', mode);
            if (reticle) reticle.setAttribute('visible', mode === 'entity');
          };
          if (!scene.is('vr-mode')) setMode('mouse');
          scene.addEventListener('enter-vr', () => setMode('entity'));
          scene.addEventListener('exit-vr', () => setMode('mouse'));
        }
      });

      /* ---------------------------------------
       * Desktop grab/drop with adjustable hold distance and throw velocity
       */
      AFRAME.registerComponent('ray-grab-desktop', {
        schema: {
          key:{default:'KeyF'},
          holdDistance:{default:1.4},
          holdYOffset:{default:-0.05}
        },
        init() {
          this.holder = document.createElement('a-entity');
          this.holder.setAttribute('position', `0 ${this.data.holdYOffset} -${this.data.holdDistance}`);
          this.el.appendChild(this.holder);

          this.held = null; // {el, hadDynamic, culled[]}
          this._tmpQ     = new THREE.Quaternion();
          this._lastDt   = 16;
          this._lastPos  = new THREE.Vector3();
          this._currPos  = new THREE.Vector3();

          this._onKey = (e) => {
            if (e.code !== this.data.key) return;
            e.preventDefault(); e.stopPropagation();
            this.toggleGrab();
          };
          window.addEventListener('keydown', this._onKey, {capture:true});
        },
        remove() {
          window.removeEventListener('keydown', this._onKey, {capture:true});
        },
        _getHolderWorldPos() {
          return this.holder.object3D.getWorldPosition(this._currPos);
        },
        _applyHolderPoseTo(el) {
          const obj = el.object3D;
          obj.position.copy(this.holder.object3D.getWorldPosition(new THREE.Vector3()));
          obj.quaternion.copy(this.holder.object3D.getWorldQuaternion(this._tmpQ));
        },
        _findTarget() {
          const rc = this.el.components.raycaster;
          if (!rc) return null;

          if (rc.intersections && rc.intersections.length) {
            const obj = rc.intersections[0].object;
            const el  = obj && obj.el;
            return (el && el.hasAttribute('grabbable')) ? el : null;
          }
          if (rc.intersectedEls && rc.intersectedEls.length) {
            for (const el of rc.intersectedEls) {
              if (el.hasAttribute('grabbable')) return el;
            }
          }
          return null;
        },
        toggleGrab() {
          if (this.held) this.release();
          else {
            const target = this._findTarget();
            if (!target) {
              console.log('[grab] rien sous le rayon');
              return;
            }
            this.grab(target);
          }
        },
        grab(el) {
          const hadDynamic = el.hasAttribute('dynamic-body');
          if (hadDynamic) el.removeAttribute('dynamic-body');

          const culled = [];
          el.object3D.traverse(n => {
            if (n.isMesh) {
              culled.push(n);
              n.frustumCulled = false;
            }
          });
          el.setAttribute('visible', 'true');

          const box = new THREE.Box3().setFromObject(el.object3D);
          const size = new THREE.Vector3();
          if (!box.isEmpty()) box.getSize(size);
          const approxRadius = Math.max(size.x, size.y, size.z) * 0.5;
          const dist = Math.max(this.data.holdDistance, approxRadius + 0.15);
          this.holder.setAttribute('position', `0 ${this.data.holdYOffset} -${dist}`);

          this._applyHolderPoseTo(el);

          this.held = { el, hadDynamic, culled };
          this._lastPos.copy(this._getHolderWorldPos());
          console.log('[grab] pris:', el);
        },
        release() {
          if (!this.held) return;
          const {el, hadDynamic, culled} = this.held;
          const worldPos = this._getHolderWorldPos();
          const dtSec = Math.max(0.016, this._lastDt / 1000);
          const vel = worldPos.clone().sub(this._lastPos).multiplyScalar(1 / dtSec);

          if (hadDynamic) {
            el.setAttribute('dynamic-body', '');
            el.addEventListener('body-loaded', function onBody() {
              el.removeEventListener('body-loaded', onBody);
              if (el.body) el.body.velocity.set(vel.x, vel.y, vel.z);
            });
          }

          culled.forEach(n => n.frustumCulled = true);
          this.held = null;
          console.log('[grab] lâché');
        },
        tick(time, dt) {
          this._lastDt = dt || 16;
          if (!this.held) return;
          this._applyHolderPoseTo(this.held.el);
          this._lastPos.copy(this._getHolderWorldPos());
        }
      });

      /* ---------------------------------------
       * Only enable look-controls when in VR; no mouse drag on desktop
       */
      AFRAME.registerComponent('look-only-in-vr', {
        init() {
          const scene = this.el.sceneEl;
          const set = (on) => {
            if (!this.el.components['look-controls'])
              this.el.setAttribute('look-controls', '');
            this.el.setAttribute('look-controls', `enabled:${on}; pointerLockEnabled:${on}`);
            const lc = this.el.components['look-controls'];
            if (lc) (on ? lc.play() : lc.pause());
          };
          set(false);
          scene.addEventListener('enter-vr', () => set(true));
          scene.addEventListener('exit-vr', () => set(false));
        }
      });

      /* For debugging raycaster events (optional) */
      AFRAME.registerComponent('raycaster-listener', {
        init() {
          const src = this.el.parentEl;
          src.addEventListener('raycaster-intersection', (e) => {
            console.log('[ray] intersections:', e.detail.intersections.length);
          });
        }
      });

      /* Console check after load */
      window.addEventListener('load', () => {
        console.log('[CHECK]', {
          AFRAME: !!window.AFRAME,
          physicsV3: !!AFRAME.systems['physics'],
          sphereCollider: !!AFRAME.components['sphere-collider'],
          superHands: !!AFRAME.components['super-hands']
        });
      });
    </script>
  </head>
  <body>
    <div class="hud">
      Déplacement : Z/Q/S/D ou flèches · Rotation : <b>A</b>/<b>E</b> ·
      Saisir/Lâcher (desktop) : <b>F</b> · Viser avec le rayon
    </div>

    <button id="enterVrBtn">Entrer en VR</button>

    <a-scene vr-mode-ui="enabled: true"
             physics="gravity: -9.8"
             shadow="type: pcfsoft"
             background="color: #ECECEC"
             autofocus-canvas>
      <!-- Floor -->
      <a-plane rotation="-90 0 0" width="12" height="12" color="#7BC8A4"
               static-body shadow="receive:true"></a-plane>

      <!-- Lighting -->
      <a-entity light="type: ambient; intensity: 0.5"></a-entity>
      <a-entity light="type: directional; intensity: 0.8; castShadow: true"
                position="1 4 2"></a-entity>

      <!-- Table (0.5 m high, smaller footprint) -->
      <a-box id="table" position="0 0.75 -2.5" width="1.2" height="0.05" depth="0.7"
             color="#8B5A2B"
             static-body
             shadow="cast:true;receive:true"></a-box>
      <!-- Table legs -->
      <a-box position="-0.55 0.375 -2.85" width="0.08" height="0.75" depth="0.08"
             color="#6E4A20" static-body shadow></a-box>
      <a-box position=" 0.55 0.375 -2.85" width="0.08" height="0.75" depth="0.08"
             color="#6E4A20" static-body shadow></a-box>
      <a-box position="-0.55 0.375 -2.15" width="0.08" height="0.75" depth="0.08"
             color="#6E4A20" static-body shadow></a-box>
      <a-box position=" 0.55 0.375 -2.15" width="0.08" height="0.75" depth="0.08"
             color="#6E4A20" static-body shadow></a-box>

      <!-- Dynamic objects on the ground (floor) -->
      <a-box position="-1.5 0.25 -3.5"
             width="0.5" height="0.5" depth="0.5"
             color="#4CC3D9"
             class="grab-target"
             grabbable dynamic-body hover-highlight auto-refresh-physics
             shadow="cast:true;receive:true"></a-box>

      <a-sphere position="-0.5 0.35 -3.8"
                radius="0.35"
                color="#EF2D5E"
                class="grab-target"
                grabbable dynamic-body hover-highlight auto-refresh-physics
                shadow="cast:true;receive:true"></a-sphere>

      <a-cylinder position="0.5 0.4 -4.0"
                  radius="0.25" height="0.8"
                  color="#66BB6A"
                  class="grab-target"
                  grabbable dynamic-body hover-highlight auto-refresh-physics
                  shadow="cast:true;receive:true"></a-cylinder>

      <a-box id="small-gun" position="1.5 0.45 -3.2"
             width="0.12" height="0.07" depth="0.22"
             color="#222"
             class="grab-target"
             grabbable dynamic-body hover-highlight auto-refresh-physics
             shadow="cast:true;receive:true"></a-box>

      <!-- Dynamic objects on the table (50 cm high, i.e. y≈0.55) -->
      <a-box position="-0.4 0.8 -2.8"
             width="0.35" height="0.35" depth="0.35"
             color="#FFAA00"
             class="grab-target"
             grabbable dynamic-body hover-highlight auto-refresh-physics
             shadow="cast:true;receive:true"></a-box>

      <a-sphere position="0.2 0.9 -2.7"
                radius="0.25"
                color="#00AAFF"
                class="grab-target"
                grabbable dynamic-body hover-highlight auto-refresh-physics
                shadow="cast:true;receive:true"></a-sphere>

      <a-cylinder position="0.6 0.85 -2.4"
                  radius="0.15" height="0.5"
                  color="#FF66AA"
                  class="grab-target"
                  grabbable dynamic-body hover-highlight auto-refresh-physics
                  shadow="cast:true;receive:true"></a-cylinder>

      <a-box id="gun"
             position="-0.8 0.8 -2.6"
             width="0.12" height="0.07" depth="0.22"
             color="#000"
             class="grab-target"
             grabbable dynamic-body hover-highlight auto-refresh-physics
             shadow="cast:true;receive:true"></a-box>

      <!-- Rig with camera and hands -->
      <a-entity id="rig" position="0 0 2.5" dual-joystick-controls>

        <!-- Camera with ray + F key grab -->
        <a-entity id="cam" camera="near:0.1; far:100" position="0 1.6 0"
                  look-controls
                  look-only-in-vr
                  cursor="rayOrigin: entity; fuse: false"
                  raycaster="objects: .grab-target; far: 8; interval: 0; showLine: true"
                  ray-grab-desktop="key: KeyF"
                  debug-hand="hand: camera">
          <!-- Reticle -->
          <a-entity id="reticle"
                    geometry="primitive: ring; radiusInner: 0.003; radiusOuter: 0.006"
                    material="color:#fff; shader: flat; opacity: 0.9"
                    position="0 0 -0.5"
                    visible="true"></a-entity>
        </a-entity>

        <!-- Left hand -->
        <a-entity id="left" laser-controls="hand: left; model: false"
                  raycaster="objects: .grab-target; far: 3; interval: 0; showLine: true"
                  super-hands="colliderEvent: raycaster-intersection; colliderEventProperty: els;
                               grabStartButtons: triggerdown, gripdown;
                               grabEndButtons: triggerup, gripup">
          <a-sphere radius="0.02" color="#39f" position="0 0 -0.05"></a-sphere>
        </a-entity>

        <!-- Right hand -->
        <a-entity id="right" laser-controls="hand: right; model: false"
                  raycaster="objects: .grab-target; far: 3; interval: 0; showLine: true"
                  super-hands="colliderEvent: raycaster-intersection; colliderEventProperty: els;
                               grabStartButtons: triggerdown, gripdown;
                               grabEndButtons: triggerup, gripup">
          <a-sphere radius="0.02" color="#f93" position="0 0 -0.05"></a-sphere>
        </a-entity>

      </a-entity>
    </a-scene>
  </body>
</html>
